# magic-java
java小型组件手写系列

## 组件简介
* mini-schedule：定时任务组件，模拟实现本地定时任务提交与调度
* mini-ThreadPool：线程池组件，模拟实现线程池提交与调度,支持设置核心线程数、最大线程数、拒绝策略，内置两个默认拒绝策略
* mini-jvm：模拟实现hotspot启动时，根据配置的主类和类加载路径，加载主类的class文件，并进行解析，然后根据字节码指令进行逐行解释执行。模拟实现了如下核心组件：
  * 启动类加载器
  * 虚拟机线程栈
  * 线程栈的栈帧
  * pc寄存器
  * 操作数栈
* mini-spring: mini版spring，模拟实现了ioc容器、springMVC的核心逻辑
  * spring-ioc: 模拟实现了spring容器启动、扫描、BeanDefinition管理，bean管理，自动注入Autowired，生命周期接口BeanPostProcessor的管理与回调，初始化注解PostConstruct扫描与回调
    * 支持注解Component
    * 支持注解Autowired
    * 支持注解PostConstruct
    * 支持接口BeanPostProcessor
    * 二级缓存解决自动注入循环依赖
  * spring-mvc: 模拟实现了一个内嵌的TomcatServer，启动阶段自动扫描管理接口路径映射（uri-WebHandler），运行阶段自动处理映射请求
    * 支持注解Controller
    * 支持注解RequestMapping
    * 支持注解RequestBody,支持三种数据类型：HTML，JSON，LOCAL（ModelAndView）
    * 支持注解PathParam

## 设计模式实践
* decorator-装饰器设计模式：不需要继承，基于组合的方式实现，有更高的灵活性，在实现功能任意组合、扩展、追加等需求场景下，该设计模式很合适
  * 案例1：带有删除记录功能的set类；
  * 案例2：带有缓存功能的文件输入流；
  * 案例3：增强spring的request注解，实现对入参requestBody的属性增强（Map类型入参，默认增加一个时间戳字段）
* iterator-迭代器设计模式：迭代器模式没什么好说的，提供判断有无下一个元素、获取下一个元素的功能，但是迭代器的使用场景是可以发挥创意的
  * 案例1：实现一个自定义业务类的成员属性遍历的迭代器
  * 案例2：实现一个能自动获取文件下一行的文件读取器
* composite-组合设计模式：组合模式我个人人为是比较难的设计模式了，一般用在树形结构中，在组合模式的应用场景下对象之间是以组合的方式相互嵌套的，比较典型的场景是sql语言解析形成AST语法树，我个人人为只有和场景高度契合，才能发挥这个设计模式的价值
  * 案例1：省市区人口计数器
  * 案例2：支持加减乘除的简单计算器（解析字符串形式的表达式，如1+((2*3)+3)-10+1/2+(1+1)，形成表达式结构树，得到表达式结果）
* chain-责任链设计模式：在进行一连串逻辑、操作的时候，这个模式就比较合适了，能有效解耦链上不同的载体，具有比较好的扩展性，如果你愿意，也可以自行开发链的控制逻辑
  * 案例：自定义对象成员属性值校验器
    * 支持多种校验注解Length、Max、Min
    * 支持链的主动提前退出
    * 支持链上下文传递
* flyweight-蝇量（享元）设计模式：这个模式我觉得是一种思想，而不是一种具体的实现方式，其实就是“复用”，场景不同，复用的含义也是不同的
  * 案例：使用享元的思想模拟实现一个kafka的内存池bufferPool，实现对内存的分配与释放
    * 可以复用的情况：slot为可复用的缓存单元，用户申请的内存大小等于slot的块大小，并且刚好有可以复用的slot块，那么就直接返回给用户复用，不需要向系统进行资源申请和释放等工作
    * 没法复用的情况：slot在必要的条件下是可以释放的，比如用户申请了一块内存，但是当前剩余的空闲内存不够了，但是加上部分释放的slot后又够了，那么该情况下缓存池就可以释放部分slot，这个情况就涉及资源的释放和申请了
